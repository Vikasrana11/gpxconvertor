<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Advanced GPX/KML/KMZ Converter</title>
  
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
  
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    .topnavbar {
      background-color: #333;
      color: white;
      padding: 10px;
      display: flex;
      align-items: center;
      flex-shrink: 0;
    }
    .topnavbar h1 {
      flex-grow: 1;
      margin: 0;
      font-size: 1.5rem;
    }
    .main-content {
      display: flex;
      flex-grow: 1;
      overflow: hidden;
    }
    .sidebar {
      width: 350px;
      background-color: #f8f9fa;
      border-right: 1px solid #dee2e6;
      padding: 15px;
      overflow-y: auto;
      transition: all 0.3s;
      flex-shrink: 0;
    }
    .sidebar.collapsed {
      width: 0;
      padding: 0;
      overflow: hidden;
    }
    .map-area {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .map-container {
      position: relative;
      width: 100%;
      height: 100%;
    }
    #map {
      width: 100%;
      height: 100%;
    }
    .ol-popup {
      background: white;
      padding: 5px 10px;
      border-radius: 4px;
      border: 1px solid #ccc;
      min-width: 150px;
      position: relative;
      bottom: 12px;
      left: -50%;
      transform: translateX(50%);
      box-shadow: 0 1px 4px rgba(0,0,0,0.2);
    }
    .close-button {
      position: absolute;
      top: 2px;
      right: 5px;
      cursor: pointer;
      font-weight: bold;
      color: #888;
    }
    .close-button:hover {
      color: #000;
    }
    #summary {
      font-size: 0.95rem;
      background: #f8f9fa;
      padding: 10px;
      border-radius: 5px;
      margin-bottom: 8px;
    }
    .download-buttons {
      margin-bottom: 8px;
    }
    #legend {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 5px;
      max-width: 180px;
      z-index: 1000;
      display: none;
    }
    #legend h4 {
      margin: 0 0 10px 0;
      font-size: 0.9rem;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }
    .legend-item svg, .legend-item img {
      margin-right: 8px;
    }
    .legend-item span {
      font-size: 0.85rem;
    }
    #layer-switch {
      position: absolute;
      top: 600px;
      left: 5px;
      z-index: 1000;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
      display: flex;
      align-items: center;
      font-size: 0.9rem;
    }
    #time-slider-container {
      position: absolute;
      top: 180px;
      left: 5px;
      z-index: 1000;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px;
      border-radius: 5px;
      border: 1px solid #ccc;
      display: none;
      width: 100px;
    }
    #time-slider {
      width: 80%;
    }
    #time-display {
      text-align: center;
      margin-top: 5px;
      font-weight: bold;
    }
    .tool-button {
      position: absolute;
      z-index: 1000;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
      cursor: pointer;
    }
    #measure-tool {
      top: 70px;
      left: 5px;
    }
    #measure-result {
      position: absolute;
      top: 160px;
      left: 10px;
      z-index: 1000;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
      display: none;
    }
    .sidebar-section {
      margin-bottom: 20px;
      border-bottom: 1px solid #ddd;
      padding-bottom: 15px;
    }
    .sidebar-section h3 {
      font-size: 1.1rem;
      margin-bottom: 10px;
      color: #333;
    }
    .file-info {
      font-size: 0.9rem;
      margin-bottom: 4px;
    }
    .file-info strong {
      display: inline-block;
      width: 110px;
    }
    .map-controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .map-control {
      background: rgba(255, 255, 255, 0.9);
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
      display: flex;
      align-items: center;
      font-size: 0.9rem;
    }
    @media (max-width: 768px) {
      .main-content {
        flex-direction: column;
      }
      .sidebar {
        width: 100%;
        height: auto;
        max-height: 300px;
      }
      .sidebar.collapsed {
        height: 0;
      }
      #legend, #layer-switch, .tool-button {
        position: static;
        max-width: 100%;
        margin: 10px auto;
        text-align: center;
      }
      #measure-result {
        position: static;
        margin: 8px auto;
      }
      #time-slider-container {
        position: static;
        width: auto;
        margin: 8px;
      }
    }
  </style>
</head>

<body>
  <div class="topnavbar">
    <button class="btn btn-dark me-3" id="toggleSidebar" aria-label="Toggle sidebar visibility">
      <i class="bi bi-list"></i>
    </button>
    <h1>Advanced GPX/KML/KMZ Converter</h1>
  </div>

  <div class="main-content">
    <div class="sidebar" id="sidebar">
      <div class="sidebar-section">
        <h3><i class="bi bi-upload me-2"></i>Upload Files</h3>
        <input class="form-control mb-3" type="file" id="inputfile" accept=".gpx,.kml,.kmz" multiple />
        <div id="file-summary">
          <strong>No files loaded</strong>
        </div>
      </div>
      
      <div class="sidebar-section">
        <h3><i class="bi bi-download me-2"></i>Download Options</h3>
        <div class="download-buttons">
          <button class="btn btn-primary btn-sm w-100 mb-2" id="downloadKml" disabled>
            <i class="bi bi-file-earmark-arrow-down me-2"></i>Download KML
          </button>
          <button class="btn btn-secondary btn-sm w-100 mb-2" id="downloadBatchKml" disabled>
            <i class="bi bi-files me-2"></i>Download Batch KML
          </button>
          <button class="btn btn-danger btn-sm w-100" id="resetButton">
            <i class="bi bi-trash me-2"></i>Reset All
          </button>
        </div>
      </div>
      
      <div class="sidebar-section">
        <h3><i class="bi bi-info-circle me-2"></i>GPX/KML Summary</h3>
        <div id="summary">
          <strong>File Summary:</strong> Load one or more .gpx, .kml, or .kmz files to see details.
        </div>
      </div>
    </div>

    <div class="map-area">
      <div class="map-container">
        <div id="map"></div>
        
        <div class="map-controls">
          <div id="layer-switch">
            <label class="google-label" for="layer-toggle">Google Satellite</label>
            <div class="form-check form-switch">
              <input class="form-check-input" type="checkbox" id="layer-toggle">
              <label class="form-check-label osm-label" for="layer-toggle">OSM</label>
            </div>
          </div>
          
          <div id="time-slider-container">
            <input type="range" min="0" max="100" value="0" class="slider" id="time-slider">
            <div id="time-display">00:00:00</div>
            <div class="d-flex justify-content-center mt-2">
              <button id="play-button" class="btn btn-sm btn-success me-2"><i class="bi bi-play me-1"></i>Play</button>
              <button id="pause-button" class="btn btn-sm btn-warning"><i class="bi bi-pause me-1"></i>Pause</button>
            </div>
          </div>
          
          <div id="measure-tool" class="tool-button" title="Measure Distance">
            <i class="bi bi-rulers"></i> Measure
          </div>
        </div>
        
        <div id="measure-result"></div>
        
        <div id="legend">
          <h4>Legend</h4>
          <div class="legend-item">
            <svg width="12" height="12"><circle cx="6" cy="6" r="6" fill="green" stroke="white" stroke-width="1"/></svg>
            <span>Start Point</span>
          </div>
          <div class="legend-item">
            <svg width="12" height="12"><circle cx="6" cy="6" r="6" fill="red" stroke="white" stroke-width="1"/></svg>
            <span>End Point</span>
          </div>
          <div class="legend-item">
            <svg width="18" height="18"><circle cx="8" cy="8" r="6" fill="yellow" stroke="white" stroke-width="2"/></svg>
            <span>Stop Point (Speed = 0 km/h)</span>
          </div>
          <div class="legend-item">
            <svg width="12" height="12"><circle cx="6" cy="6" r="4" fill="blue" stroke="white" stroke-width="1"/></svg>
            <span>Track Point</span>
          </div>
          <div class="legend-item">
            <img src="https://cdn-icons-png.flaticon.com/512/252/252025.png" width="12" height="12" style="object-fit: contain;" />
            <span>Waypoint</span>
          </div>
          <div class="legend-item">
            <svg width="20" height="4"><line x1="0" y1="2" x2="20" y2="2" stroke="red" stroke-width="3"/></svg>
            <span>Track</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/ol@7.5.2/dist/ol.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <script>
    document.addEventListener("DOMContentLoaded", function () {
      let map;
      let vectorSource = new ol.source.Vector();
      let vectorLayer;
      let allFeatures = [];
      let osmLayer, googleSatelliteLayer;
      let measureToolActive = false;
      let measureTool;
      let animationInterval;
      let currentTrackPoints = [];
      let animationPosition = 0;
      let animationFeatures = [];
      
      // Initialize map
      initMap();
      setupEventListeners();

      function initMap() {
        // Set Google Satellite as default
        osmLayer = new ol.layer.Tile({
          source: new ol.source.OSM(),
          visible: false
        });
        
        googleSatelliteLayer = new ol.layer.Tile({
          source: new ol.source.XYZ({
            url: 'https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',
          }),
          visible: true
        });

        vectorSource = new ol.source.Vector();
        vectorLayer = new ol.layer.Vector({
          source: vectorSource,
          style: styleFunction,
        });

        map = new ol.Map({
          target: "map",
          layers: [
            googleSatelliteLayer,
            osmLayer,
            vectorLayer
          ],
          view: new ol.View({
            center: ol.proj.fromLonLat([80.3, 19.8]),
            zoom: 4
          })
        });

        document.getElementById("layer-toggle").addEventListener("change", function (e) {
          const isOSM = e.target.checked;
          osmLayer.setVisible(isOSM);
          googleSatelliteLayer.setVisible(!isOSM);
        });

        const popupContainer = document.createElement("div");
        popupContainer.className = "ol-popup";
        const popupContent = document.createElement("div");
        const closeBtn = document.createElement("div");
        closeBtn.className = "close-button";
        closeBtn.innerHTML = "×";
        popupContainer.appendChild(closeBtn);
        popupContainer.appendChild(popupContent);

        const overlay = new ol.Overlay({
          element: popupContainer,
          positioning: "bottom-center",
          offset: [0, -10],
          stopEvent: false
        });
        closeBtn.onclick = () => overlay.setPosition(undefined);
        map.addOverlay(overlay);

        map.on("click", function (evt) {
          let found = false;
          map.forEachFeatureAtPixel(evt.pixel, function (feature) {
            const props = feature.getProperties();
            if (!props) return;

            if (feature.getGeometry().getType() === "Point") {
              const coord = feature.getGeometry().getCoordinates();
              let infoHtml = "";
              if (props.type === "stop") {
                infoHtml = `<strong>Stop Point</strong><br/>
                Lat: ${props.lat}<br/>Lon: ${props.lon}<br/>Time: ${props.istTime || "N/A"}`;
              } else if (props.type === "waypoint") {
                infoHtml = `<strong>Waypoint</strong><br/>Name: ${props.name || "N/A"}<br/>Lat: ${props.lat}<br/>Lon: ${props.lon}`;
              } else if (props.type === "trackpoint" || props.type === "start" || props.type === "end") {
                infoHtml = `<strong>Track Point</strong><br/>
                Lat: ${props.lat}<br/>Lon: ${props.lon}<br/>
                Elevation: ${props.elevation || "N/A"} m<br/>
                Time (IST): ${props.istTime || "N/A"}<br/>
                Speed: ${props.speed !== undefined ? props.speed.toFixed(2) : "N/A"} km/h`;
              } else {
                infoHtml = `<strong>Point</strong><br/>Lat: ${props.lat}<br/>Lon: ${props.lon}`;
              }
              popupContent.innerHTML = infoHtml;
              overlay.setPosition(coord);
              found = true;
            }
          });
          if (!found) overlay.setPosition(undefined);
        });

        measureTool = new ol.interaction.Draw({
          source: vectorSource,
          type: 'LineString',
          style: new ol.style.Style({
            stroke: new ol.style.Stroke({
              color: 'rgba(0, 0, 255, 0.7)',
              width: 2
            })
          })
        });
        measureTool.setActive(false);
        map.addInteraction(measureTool);

        measureTool.on('drawend', function(evt) {
          const line = evt.feature.getGeometry();
          const coordinates = line.getCoordinates();
          let totalDistance = 0;
          
          for (let i = 1; i < coordinates.length; i++) {
            const from = ol.proj.toLonLat(coordinates[i-1]);
            const to = ol.proj.toLonLat(coordinates[i]);
            totalDistance += haversine(from[1], from[0], to[1], to[0]);
          }
          
          document.getElementById('measure-result').innerHTML = `Distance: ${(totalDistance/1000).toFixed(2)} km`;
          document.getElementById('measure-result').style.display = 'block';
          
          setTimeout(() => {
            vectorSource.removeFeature(evt.feature);
            document.getElementById('measure-result').style.display = 'none';
          }, 5000);
        });
      }

      function setupEventListeners() {
        document.getElementById("toggleSidebar").addEventListener("click", function() {
          document.getElementById("sidebar").classList.toggle("collapsed");
          // Update map size when sidebar changes
          setTimeout(() => {
            map.updateSize();
          }, 300);
        });

        document.getElementById("inputfile").addEventListener("change", function (event) {
          const files = event.target.files;
          if (!files.length) return;

          // Update file summary
          let fileSummary = `<strong>Files to process (${files.length}):</strong><br>`;
          for (let i = 0; i < files.length; i++) {
            fileSummary += `<div class="file-info"><strong>File ${i+1}:</strong> ${files[i].name}</div>`;
          }
          document.getElementById("file-summary").innerHTML = fileSummary;

          for (const file of files) {
            const reader = new FileReader();
            reader.onload = async function (e) {
              try {
                let data;
                const fileName = file.name.toLowerCase();
                if (fileName.endsWith('.gpx')) {
                  data = parseGPX(e.target.result, file.name);
                } else if (fileName.endsWith('.kml')) {
                  data = parseKML(e.target.result, file.name);
                } else if (fileName.endsWith('.kmz')) {
                  const zip = await JSZip.loadAsync(file);
                  const kmlFile = Object.keys(zip.files).find(name => name.endsWith('.kml'));
                  if (!kmlFile) throw new Error('No KML file found in KMZ');
                  const kmlContent = await zip.file(kmlFile).async('string');
                  data = parseKML(kmlContent, file.name);
                } else {
                  throw new Error('Unsupported file type');
                }
                allFeatures.push(data);
                vectorSource.addFeatures(data.features);
                updateSummary();
                if (data.features.some(f => f.get('type') === 'trackpoint')) {
                  setupTimeSlider(data);
                }
                
                const extent = vectorSource.getExtent();
                if (!ol.extent.isEmpty(extent)) {
                  map.getView().fit(extent, { padding: [50, 50, 50, 50], maxZoom: 15 });
                }

                document.getElementById("downloadKml").onclick = () => {
                  const kml = generateKML(data);
                  const kmlFileName = data.name.replace(/\.gpx|\.kml|\.kmz$/i, ".kml");
                  downloadKML(kml, kmlFileName);
                };

                document.getElementById("downloadBatchKml").onclick = async () => {
                  const batchKml = allFeatures.map((data, index) => generateKML({ ...data, name: data.name || `File_${index + 1}` })).join("\n");
                  const batchKmlWrapper = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
${batchKml.replace(/<\?xml[^>]*>\n<kml[^>]*>\n\s*<Document>\n|\n\s*<\/Document>\n\s*<\/kml>/g, "")}
  </Document>
</kml>`;
                  await downloadKML(batchKmlWrapper, "batch_files.kml");
                };
              } catch (err) {
                alert(`Error parsing file "${file.name}": ${err.message}`);
              }
            };
            reader.onerror = function () {
              alert(`Error reading file "${file.name}"`);
            };
            if (file.name.toLowerCase().endsWith('.kmz')) {
              reader.readAsArrayBuffer(file);
            } else {
              reader.readAsText(file);
            }
          }
        });

        document.getElementById("resetButton").addEventListener("click", function () {
          resetMap();
          document.getElementById("file-summary").innerHTML = "<strong>No files loaded</strong>";
        });

        document.getElementById("measure-tool").addEventListener("click", function() {
          measureToolActive = !measureToolActive;
          measureTool.setActive(measureToolActive);
          this.style.backgroundColor = measureToolActive ? '#d4edda' : '';
        });

        document.getElementById('play-button').addEventListener('click', startAnimation);
        document.getElementById('pause-button').addEventListener('click', pauseAnimation);
        document.getElementById('time-slider').addEventListener('input', function() {
          if (animationInterval) pauseAnimation();
          updateAnimationPosition(this.value);
        });
      }

      function parseKML(xmlString, filename) {
        try {
          const parser = new DOMParser();
          const kml = parser.parseFromString(xmlString, "application/xml");
          if (kml.documentElement.nodeName === "parsererror") {
            throw new Error("Invalid XML format");
          }

          const features = [];
          const lineCoords = [];
          let totalDistance = 0;
          const placemarks = kml.getElementsByTagName("Placemark");
          let startTime = null;
          let endTime = null;
          const speeds = [];
          const elevations = [];

          for (const placemark of placemarks) {
            const point = placemark.getElementsByTagName("Point")[0];
            const lineString = placemark.getElementsByTagName("LineString")[0];
            const extendedData = placemark.getElementsByTagName("ExtendedData")[0];
            let props = {};

            if (extendedData) {
              for (const data of extendedData.getElementsByTagName("Data")) {
                const name = data.getAttribute("name");
                const value = data.getElementsByTagName("value")[0]?.textContent;
                if (name && value) props[name] = value;
              }
            }

            const name = placemark.getElementsByTagName("name")[0]?.textContent || null;

            if (point) {
              const coordinates = point.getElementsByTagName("coordinates")[0]?.textContent.trim().split(",");
              if (coordinates.length < 2) continue;
              const lon = parseFloat(coordinates[0]);
              const lat = parseFloat(coordinates[1]);
              const elevation = coordinates[2] ? parseFloat(coordinates[2]) : 0;

              if (isNaN(lat) || isNaN(lon)) continue;

              features.push(
                new ol.Feature({
                  geometry: new ol.geom.Point(ol.proj.fromLonLat([lon, lat])),
                  lat,
                  lon,
                  elevation,
                  name,
                  type: props.type || "waypoint",
                  time: props.time || null,
                  istTime: props.time ? convertToIST(props.time) : "N/A",
                  speed: props.speed ? parseFloat(props.speed) : undefined
                })
              );

              if (props.type === "trackpoint" && props.time) {
                if (!startTime) startTime = props.time;
                endTime = props.time;
                if (props.speed !== undefined) speeds.push(parseFloat(props.speed));
                if (elevation !== undefined) elevations.push(elevation);
              }
            } else if (lineString) {
              const coordinates = lineString.getElementsByTagName("coordinates")[0]?.textContent.trim().split(/\s+/);
              const coords = coordinates.map(coord => {
                const [lon, lat, ele] = coord.split(",").map(parseFloat);
                if (isNaN(lon) || isNaN(lat)) return null;
                lineCoords.push([lon, lat]);
                return ol.proj.fromLonLat([lon, lat]);
              }).filter(coord => coord !== null);

              if (coords.length > 1) {
                for (let i = 1; i < coords.length; i++) {
                  const from = ol.proj.toLonLat(coords[i-1]);
                  const to = ol.proj.toLonLat(coords[i]);
                  totalDistance += haversine(from[1], from[0], to[1], to[0]);
                }

                features.push(
                  new ol.Feature({
                    geometry: new ol.geom.LineString(coords),
                    type: "track"
                  })
                );
              }
            }
          }

          if (lineCoords.length > 0) {
            const firstPoint = features.find(f => f.get("type") === "trackpoint");
            const lastPoint = features.filter(f => f.get("type") === "trackpoint").slice(-1)[0];
            if (firstPoint) firstPoint.set("type", "start");
            if (lastPoint) lastPoint.set("type", "end");

            for (let i = 0; i < speeds.length; i++) {
              if (speeds[i] === 0) {
                const point = features[i];
                if (point && point.get("type") === "trackpoint") {
                  point.set("type", "stop");
                }
              }
            }
          }

          return { features, totalDistance, elevations, startTime, endTime, speeds, name: filename };
        } catch (err) {
          throw new Error(`Failed to parse KML/KMZ: ${err.message}`);
        }
      }

      function setupTimeSlider(data) {
        const trackPoints = data.features.filter(f => 
          f.get('type') === 'trackpoint' || f.get('type') === 'start' || f.get('type') === 'end'
        );
        
        if (trackPoints.length === 0) return;
        
        currentTrackPoints = trackPoints;
        document.getElementById('time-slider-container').style.display = 'block';
        
        animationFeatures = [];
        trackPoints.forEach((pt, i) => {
          const feature = new ol.Feature({
            geometry: pt.getGeometry(),
            index: i,
            time: pt.get('time'),
            istTime: pt.get('istTime')
          });
          
          const style = new ol.style.Style({
            image: new ol.style.Circle({
              radius: 8,
              fill: new ol.style.Fill({ color: 'rgba(255, 0, 0, 0.8)' }),
              stroke: new ol.style.Stroke({ color: 'white', width: 2 })
            })
          });
          
          feature.setStyle(style);
          animationFeatures.push(feature);
        });
      }

      function startAnimation() {
        if (animationInterval) clearInterval(animationInterval);
        
        const slider = document.getElementById('time-slider');
        const totalPoints = currentTrackPoints.length;
        const duration = 30000;
        const interval = duration / totalPoints;
        let currentIndex = parseInt(slider.value);
        
        animationInterval = setInterval(() => {
          currentIndex++;
          if (currentIndex >= totalPoints) {
            currentIndex = 0;
          }
          
          slider.value = currentIndex;
          updateAnimationPosition(currentIndex);
        }, interval);
      }

      function pauseAnimation() {
        if (animationInterval) {
          clearInterval(animationInterval);
          animationInterval = null;
        }
      }

      function updateAnimationPosition(position) {
        const index = parseInt(position);
        if (index < 0 || index >= currentTrackPoints.length) return;
        
        const point = currentTrackPoints[index];
        const timeDisplay = document.getElementById('time-display');
        timeDisplay.textContent = point.get('istTime') || 'N/A';
        
        vectorSource.clear();
        vectorSource.addFeatures(animationFeatures.slice(0, index + 1));
        
        const view = map.getView();
        view.setCenter(point.getGeometry().getCoordinates());
      }

      function resetMap() {
        allFeatures = [];
        vectorSource.clear();
        document.getElementById("summary").innerHTML = "<strong>File Summary:</strong> Load one or more .gpx, .kml, or .kmz files to see details.";
        document.getElementById("downloadKml").disabled = true;
        document.getElementById("downloadBatchKml").disabled = true;
        document.getElementById("inputfile").value = "";
        document.getElementById("legend").style.display = "none";
        document.getElementById("time-slider-container").style.display = "none";
        map.getView().setCenter(ol.proj.fromLonLat([80.3, 19.8]));
        map.getView().setZoom(4);
        
        if (animationInterval) {
          clearInterval(animationInterval);
          animationInterval = null;
        }
        currentTrackPoints = [];
        animationFeatures = [];
      }

      function haversine(lat1, lon1, lat2, lon2) {
        const R = 6371000;
        const toRad = (x) => (x * Math.PI) / 180;
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a =
          Math.sin(dLat / 2) ** 2 +
          Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      function convertToIST(utcStr) {
        if (!utcStr) return "N/A";
        try {
          const date = new Date(utcStr);
          if (isNaN(date.getTime())) return "N/A";
          return new Intl.DateTimeFormat("en-GB", {
            timeZone: "Asia/Kolkata",
            hour12: false,
            year: "numeric",
            month: "short",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
          }).format(date).replace(",", "");
        } catch {
          return "N/A";
        }
      }

      function styleFunction(feature) {
        const geomType = feature.getGeometry().getType();
        const props = feature.getProperties();

        if (geomType === "Point") {
          if (props.type === "start") {
            return new ol.style.Style({
              image: new ol.style.Circle({
                radius: 6,
                fill: new ol.style.Fill({ color: "green" }),
                stroke: new ol.style.Stroke({ color: "white", width: 1 })
              })
            });
          } else if (props.type === "end") {
            return new ol.style.Style({
              image: new ol.style.Circle({
                radius: 8,
                fill: new ol.style.Fill({ color: "red" }),
                stroke: new ol.style.Stroke({ color: "white", width: 1 })
              })
            });
          } else if (props.type === "stop") {
            return new ol.style.Style({
              image: new ol.style.Circle({
                radius: 10,
                fill: new ol.style.Fill({ color: "yellow" }),
                stroke: new ol.style.Stroke({ color: "white", width: 1 })
              })
            });
          } else if (props.type === "waypoint") {
            return new ol.style.Style({
              image: new ol.style.Icon({
                src: "https://cdn-icons-png.flaticon.com/512/252/252025.png",
                scale: 0.05,
                anchor: [0.5, 1]
              })
            });
          } else {
            return new ol.style.Style({
              image: new ol.style.Circle({
                radius: 4,
                fill: new ol.style.Fill({ color: "blue" }),
                stroke: new ol.style.Stroke({ color: "white", width: 1 })
              })
            });
          }
        } else if (geomType === "LineString") {
          return new ol.style.Style({
            stroke: new ol.style.Stroke({
              color: "red",
              width: 3
            })
          });
        }
        return null;
      }

      function generateKML({ features, name }) {
        let kmlOutput = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${name || "File Data"}</name>
    <Style id="trackStyle">
      <LineStyle>
        <color>ff0000ff</color>
        <width>3</width>
      </LineStyle>
    </Style>
    <Style id="startPoint">
      <IconStyle>
        <color>ff00ff00</color>
        <scale>1.2</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/paddle/grn-circle.png</href>
        </Icon>
      </IconStyle>
    </Style>
    <Style id="endPoint">
      <IconStyle>
        <color>ff0000ff</color>
        <scale>1.2</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/paddle/red-circle.png</href>
        </Icon>
      </IconStyle>
    </Style>
    <Style id="stopPoint">
      <IconStyle>
        <color>ff00ffff</color>
        <scale>1.0</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/paddle/ylw-circle.png</href>
        </Icon>
      </IconStyle>
    </Style>
    <Style id="waypoint">
      <IconStyle>
        <scale>1.0</scale>
        <Icon>
          <href>https://cdn-icons-png.flaticon.com/512/252/252025.png</href>
        </Icon>
      </IconStyle>
    </Style>
    <Style id="trackPoint">
      <IconStyle>
        <color>ffff0000</color>
        <scale>0.8</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/paddle/blu-circle.png</href>
        </Icon>
      </IconStyle>
    </Style>`;

        features.forEach((feature) => {
          const geom = feature.getGeometry();
          const props = feature.getProperties();
          const type = props.type;

          if (geom.getType() === "Point") {
            const [lon, lat] = ol.proj.toLonLat(geom.getCoordinates());
            let styleId = type === "start" ? "startPoint" :
                          type === "end" ? "endPoint" :
                          type === "stop" ? "stopPoint" :
                          type === "waypoint" ? "waypoint" : "trackPoint";

            kmlOutput += `
    <Placemark>
      <styleUrl>#${styleId}</styleUrl>
      <Point>
        <coordinates>${lon},${lat}</coordinates>
      </Point>
      <ExtendedData>
        <Data name="type"><value>${type}</value></Data>
        ${props.name ? `<Data name="name"><value>${props.name}</value></Data>` : ""}
        ${props.elevation ? `<Data name="elevation"><value>${props.elevation}</value></Data>` : ""}
        ${props.time ? `<Data name="time"><value>${props.time}</value></Data>` : ""}
        ${props.istTime ? `<Data name="istTime"><value>${props.istTime}</value></Data>` : ""}
        ${props.speed !== undefined ? `<Data name="speed"><value>${props.speed.toFixed(2)}</value></Data>` : ""}
      </ExtendedData>
    </Placemark>`;
          } else if (geom.getType() === "LineString") {
            const coordinates = geom.getCoordinates().map(coord => {
              const [lon, lat] = ol.proj.toLonLat(coord);
              return `${lon},${lat}`;
            }).join(" ");

            kmlOutput += `
    <Placemark>
      <styleUrl>#trackStyle</styleUrl>
      <LineString>
        <tessellate>1</tessellate>
        <coordinates>${coordinates}</coordinates>
      </LineString>
      <ExtendedData>
        <Data name="type"><value>track</value></Data>
      </ExtendedData>
    </Placemark>`;
          }
        });

        kmlOutput += `
  </Document>
</kml>`;
        return kmlOutput;
      }

      async function downloadKML(data, filename) {
        try {
          if (window.showSaveFilePicker) {
            const suggestedName = filename || "output.kml";
            const fileHandle = await window.showSaveFilePicker({
              suggestedName: suggestedName,
              types: [{ description: "KML Files", accept: { "application/vnd.google-earth.kml+xml": [".kml"] } }]
            });
            const writable = await fileHandle.createWritable();
            await writable.write(data);
            await writable.close();
          } else {
            const blob = new Blob([data], { type: "application/vnd.google-earth.kml+xml" });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
          }
        } catch (err) {
          if (err.name === "AbortError") {
            console.log("User cancelled the save dialog");
          } else {
            console.error("Error saving file:", err);
            alert(`Failed to save file: ${err.message}`);
          }
        }
      }

      function parseGPX(xmlString, filename) {
        try {
          const parser = new DOMParser();
          const gpx = parser.parseFromString(xmlString, "application/xml");
          if (gpx.documentElement.nodeName === "parsererror") {
            throw new Error("Invalid XML format");
          }

          const trkpts = Array.from(gpx.getElementsByTagName("trkpt"));
          const wpts = Array.from(gpx.getElementsByTagName("wpt"));
          const features = [];
          const lineCoords = [];
          const speeds = [];
          let totalDistance = 0;
          const elevations = [];

          for (let i = 0; i < trkpts.length; i++) {
            const pt = trkpts[i];
            const lat = parseFloat(pt.getAttribute("lat"));
            const lon = parseFloat(pt.getAttribute("lon"));
            if (isNaN(lat) || isNaN(lon)) {
              console.warn(`Invalid lat/lon for trackpoint ${i}`);
              continue;
            }

            const ele = parseFloat(pt.getElementsByTagName("ele")[0]?.textContent || 0);
            const timeStr = pt.getElementsByTagName("time")[0]?.textContent || null;
            let speed = 0;
            if (i > 0 && timeStr) {
              const prev = trkpts[i - 1];
              const prevLat = parseFloat(prev.getAttribute("lat"));
              const prevLon = parseFloat(prev.getAttribute("lon"));
              const prevTimeStr = prev.getElementsByTagName("time")[0]?.textContent;
              if (!isNaN(prevLat) && !isNaN(prevLon) && prevTimeStr) {
                const dist = haversine(prevLat, prevLon, lat, lon);
                totalDistance += dist;
                const timeDiff = (new Date(timeStr) - new Date(prevTimeStr)) / 1000;
                if (timeDiff > 0) speed = (dist / timeDiff) * 3.6;
              }
            }

            speeds.push(speed);
            elevations.push(ele);
            lineCoords.push([lon, lat]);
            features.push(
              new ol.Feature({
                geometry: new ol.geom.Point(ol.proj.fromLonLat([lon, lat])),
                lat,
                lon,
                elevation: ele,
                time: timeStr,
                istTime: convertToIST(timeStr),
                speed,
                type: "trackpoint"
              })
            );
          }

          if (features.length > 0) {
            features[0].set("type", "start");
            features[features.length - 1].set("type", "end");
          }

          for (let i = 0; i < speeds.length; i++) {
            if (speeds[i] === 0) {
              const pt = trkpts[i];
              const lat = parseFloat(pt.getAttribute("lat"));
              const lon = parseFloat(pt.getAttribute("lon"));
              if (isNaN(lat) || isNaN(lon)) continue;
              const timeStr = pt.getElementsByTagName("time")[0]?.textContent || null;
              features.push(
                new ol.Feature({
                  geometry: new ol.geom.Point(ol.proj.fromLonLat([lon, lat])),
                  lat,
                  lon,
                  istTime: convertToIST(timeStr),
                  speed: speeds[i],
                  type: "stop"
                })
              );
            }
          }

          if (lineCoords.length > 1) {
            features.push(
              new ol.Feature({
                geometry: new ol.geom.LineString(lineCoords.map((c) => ol.proj.fromLonLat(c))),
                type: "track"
              })
            );
          }

          for (const wpt of wpts) {
            const lat = parseFloat(wpt.getAttribute("lat"));
            const lon = parseFloat(wpt.getAttribute("lon"));
            if (isNaN(lat) || isNaN(lon)) continue;
            const name = wpt.getElementsByTagName("name")[0]?.textContent || null;
            features.push(
              new ol.Feature({
                geometry: new ol.geom.Point(ol.proj.fromLonLat([lon, lat])),
                lat,
                lon,
                name,
                type: "waypoint"
              })
            );
          }

          return { features, totalDistance, elevations, startTime: trkpts[0]?.getElementsByTagName("time")[0]?.textContent, endTime: trkpts[trkpts.length - 1]?.getElementsByTagName("time")[0]?.textContent, speeds, name: filename };
        } catch (err) {
          throw new Error(`Failed to parse GPX: ${err.message}`);
        }
      }

      function updateSummary() {
        let trackCount = 0;
        let waypointCount = 0;
        let stopCount = 0;
        let totalDistance = 0;
        let minElevation = Infinity;
        let maxElevation = -Infinity;
        let startTime = null;
        let endTime = null;
        let speeds = [];
        let trackFiles = 0;

        for (const fileData of allFeatures) {
          for (const f of fileData.features) {
            const t = f.get("type");
            if (t === "trackpoint" || t === "start" || t === "end") trackCount++;
            else if (t === "waypoint") waypointCount++;
            else if (t === "stop") stopCount++;
            if (f.get("elevation") !== undefined && !isNaN(f.get("elevation"))) {
              minElevation = Math.min(minElevation, f.get("elevation"));
              maxElevation = Math.max(maxElevation, f.get("elevation"));
            }
            if (f.get("speed") !== undefined && !isNaN(f.get("speed"))) speeds.push(f.get("speed"));
          }
          totalDistance += fileData.totalDistance || 0;
          if (fileData.startTime) startTime = fileData.startTime;
          if (fileData.endTime) endTime = fileData.endTime;
          if (fileData.features.some(f => f.get("type") === "track")) trackFiles++;
        }

        const minSpeed = speeds.length > 0 ? Math.min(...speeds) : 0;
        const maxSpeed = speeds.length > 0 ? Math.max(...speeds) : 0;
        const avgSpeed = speeds.length > 0 ? speeds.reduce((a, b) => a + b, 0) / speeds.length : 0;

        const summaryHTML = `
          <strong>File Summary:</strong><br/>
          Tracks: ${trackFiles}<br/>
          Waypoints: ${waypointCount}<br/>
          Track Points: ${trackCount}<br/>
          Stop Points: ${stopCount}<br/>
          Start Time (IST): ${startTime ? convertToIST(startTime) : "N/A"}<br/>
          End Time (IST): ${endTime ? convertToIST(endTime) : "N/A"}<br/>
          Elevation (min → max): ${minElevation !== Infinity ? minElevation.toFixed(2) : "N/A"} m → ${maxElevation !== -Infinity ? maxElevation.toFixed(2) : "N/A"} m<br/>
          Distance: ${(totalDistance / 1000).toFixed(2)} km<br/>
          Speed (km/h):<br/>
          Min: ${minSpeed.toFixed(2)}<br/>
          Max: ${maxSpeed.toFixed(2)}<br/>
          Average: ${avgSpeed.toFixed(2)}
        `;
        document.getElementById("summary").innerHTML = summaryHTML;
        document.getElementById("downloadKml").disabled = allFeatures.length === 0;
        document.getElementById("downloadBatchKml").disabled = allFeatures.length < 2;
        document.getElementById("legend").style.display = allFeatures.length > 0 ? "block" : "none";
      }
    });
  </script>
</body>
</html>
